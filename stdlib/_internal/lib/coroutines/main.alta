# TODO: add fine-resolution importing, to allow this for example:
#           import Runtime.Native._Alta_basic_class from "meta"
import "meta/lib/runtime/native" as native
import Queue from "queue"
import free from "memory"
import List from "list"
import Size, uint64, UInt64Maximum from "types"

##if platform == "windows"
	import "./arch/windows.alta" as arch
##else
	import "./arch/posix.alta" as arch
##end if

export arch.HandleType

export type ID = uint64

type Coro = ptr native._Alta_basic_coroutine

#
# TODO: don't use regular old Queue for our workqueue
#       it's pretty inefficient since it will reallocate memory every time we `push` and `pop` to/from it
#
#       it's fine for Queue to do that for most use cases, but for us, we need to be constantly pushing and popping,
#       and often we have to pop and then push the same value right back, so it'd be nice for us to have a more
#       efficient implementation where we manually determine when workitems' lifetimes end
#

export class Scheduler {
	private var work = new Queue<Coro>
	private var sleeping = new Queue<Coro>

	# doesn't really matter if this overflows
	# for one, `2**64 - 1` is a *really* big value, so it's unlikely we'll ever run into it
	# two, if we *do* hit it, it's unlikely that the first coroutine will still be around when
	# the counter wraps back around (again: `2**64 - 1` is a **really** big value)
	#
	# `0` is the value that is off-limits (since all coroutines are initialized with it)
	private var counter: uint64 = 0

	# used by us internally and by the compiler
	private function _schedule(coroutine: Coro): ID {
		# NOTE: this commented-out code is for if we want to guarantee that the given coroutine will run
		#       immediately after being scheduled. i'm not sure if we want those semantics or not.
		#       for now, we have it commented out which has the result of making the semantics effectively
		#       be that the coroutine will run whenever the scheduler decides (which at the moment means it
		#       depends on how long the workqueue is)
		#if !coroutine.basic_suspendable.done
		#	coroutine.next(coroutine)
		#if coroutine.basic_suspendable.done
		#	return coroutine

		let id: ID = coroutine.id = ++this.counter
		this.work.push(coroutine)
		return id
	}

	# @brief Schedules a coroutine to run independently
	# @param co The coroutine to schedule
	# @desc This method schedules a given coroutine to run on this Scheduler whenever it gets a chance.
	# @note You **must not** execute the coroutine passed in after scheduling it. The *only* thing you may do with
	#       the coroutine is check whether it is done. Once it is done, you are then free to use it as you please
	#       once again (since the scheduler will have given up control over it).
	public function schedule(co: Coro): ID {
		return this._schedule(co)
	}

	# @brief Completes one iteration of a scheduled coroutine
	# @returns A boolean indicating whether you should call this method again (if `true`), or not (if `false`)
	public function tick(): bool {
		if this.work.length == 0
			return false
		let co = this.work.pop()
		if !co.waiting_for || co.waiting_for.basic_suspendable.done {
			co.next(co)
			if co.waiting_for && co.waiting_for.id == 0 {
				# we're now waiting for a new coroutine; schedule it!
				this._schedule(co.waiting_for)
			}
		}
		if !co.basic_suspendable.done {
			this.work.push(co)
		}
		return true
	}

	# @brief Indicates whether this Scheduler has any coroutines currently scheduled that can be immediately run
	public @read function hasWorkReady(): bool {
		return this.work.length != 0
	}

	# @brief Indicates whether this Scheduler has any coroutines that *can* run, including any that may be currently sleeping
	public @read function hasWork(): bool {
		return this.work.length != 0 || this.sleeping.length != 0
	}

	# @brief Schedules the given coroutine and waits for it to finish
	# @param coroutine A pointer to the coroutine to schedule and finish
	# @returns The same coroutine pointer passed in
	# @note This method waits for the coroutine, but it also runs other coroutines as they normally would be,
	#       and as such, those iterations will also be waited for
	public function runToCompletion(coroutine: Coro): Coro {
		# NOTE: same note as in `_schedule`; i'm not sure if we want this quick-exit behavior
		#if !coroutine.basic_suspendable.done
		#	coroutine.next(coroutine)
		#if coroutine.basic_suspendable.done
		#	return;

		this.work.push(coroutine)
		while !coroutine.basic_suspendable.done
			this.tick()
		return coroutine
	}

	# @brief Waits for all scheduled coroutines to finish running
	public function finishAll(): void {
		while this.tick() {}
	}

	# @brief Tells you whether the given coroutine is scheduled to run
	# @param co The coroutine to check for
	# @returns A value indicating whether the coroutine is scheduled to run
	# @note This method can only tell you if the coroutine is *currently* scheduled to run. Thats means that
	#       the coroutine might not be valid by the time you use it or it might never have been valid. There is no way
	#       to ask the scheduler whether the coroutine was previously scheduled; the only way to know that is if you scheduled
	#       it yourself or know that someone else did.
	# @note This method will tell you if the coroutine is *scheduled to run*. To know if it's sleeping, use `isSleeping`,
	#       and if you want to know if it's either scheduled to run or sleeping, use `isManaged`.
	public function isScheduled(co: ID): bool {
		for item: Coro in this.work.items {
			if item.id == co
				return true
		}
		return false
	}

	# @brief Tells you whether the given coroutine is currently sleeping
	# @param co The coroutine to check for
	# @returns A value indicating whether the coroutine is sleeping
	# @note Please refer to the first note on `isScheduled`. Like `isScheduled`, this method can only tell you if the coroutine
	#       is *currently* sleeping, not whether it has been previously.
	# @note This method will tell you if the coroutine is *sleeping*. To know if it's scheduled to run, use `isScheduled`,
	#       and if you want to know if it's either scheduled to run or sleeping, use `isManaged`.
	public function isSleeping(co: ID): bool {
		for item: Coro in this.sleeping.items {
			if item.id == co
				return true
		}
		return false
	}

	# @brief Tells you whether the given coroutine is being managed by this Scheduler
	# @param co The coroutine to check for
	# @returns A value indicating whether the coroutine is being managed by this Scheduler
	# @note Please refer to the first note on `isScheduled`. Like `isScheduled`, this method can only tell you if the coroutine
	#       is *currently* being managed by this Scheduler, not whether is has been previously.
	# @note This method will tell you if the coroutine is *being managed by this Scheduler*, which includes either
	#       currently running or sleeping. To know specifically if it's scheduled to run, use `isScheduled`,
	#       and to know specifically if it's sleeping, use `isSleeping`.
	public function isManaged(co: ID): bool {
		return this.isScheduled(co) || this.isSleeping(co)
	}
}
