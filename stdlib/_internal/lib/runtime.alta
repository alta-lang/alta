import rawconststring, uint64 from "types"
import "meta/lib/runtime/native" as native
import unsafeAllocate, unsafeFree from "memory"
import rawstringsEqual from "string"
import abort from "libc/lib/stdlib"

export literal function _Alta_bad_cast(fromTypeName: rawconststring, toTypeName: rawconststring): void {
	abort()
}

export literal function _Alta_bad_enum(enumTypeName: rawconststring, badEnumValue: uint64): void {
	abort()
}

function _Alta_get_base(inst: ptr native._Alta_basic_class): ptr native._Alta_basic_class {
	return ((inst as ptr byte) - inst.instance_info.class_info.offset_from_base) as ptr native._Alta_basic_class
}

function _Alta_get_next(inst: ptr native._Alta_basic_class): ptr native._Alta_basic_class {
	let offset = inst.instance_info.class_info.offset_to_next
	if offset == 0 {
		return nullptr
	}
	return ((inst as ptr byte) + offset) as ptr native._Alta_basic_class
}

function _Alta_get_real(inst: ptr native._Alta_basic_class): ptr native._Alta_basic_class {
	return ((inst as ptr byte) - inst.instance_info.class_info.offset_from_real) as ptr native._Alta_basic_class
}

function _Alta_get_owner(inst: ptr native._Alta_basic_class): ptr native._Alta_basic_class {
	return ((inst as ptr byte) - inst.instance_info.class_info.offset_from_owner) as ptr native._Alta_basic_class
}

export literal function _Alta_get_child(instance: ptr void, parentContainers: rawconststring...): ptr void {
	let inst = instance as ptr native._Alta_basic_class

	for i: uint64 in 0..parentContainers.length {
		let parentContainer = parentContainers[i]
		let first = _Alta_get_real(inst)
		let curr = first

		# look through the instances of the class to find one whose parent container
		# (i.e. the child that owns it) is equal to the one we're looking for
		while curr {
			assert curr.instance_info.class_info.child_name
			if rawstringsEqual(curr.instance_info.class_info.child_name, parentContainer) {
				curr = _Alta_get_owner(curr)
				break
			}

			curr = _Alta_get_next(curr)
		}

		# we *must* have found an instance of it
		assert curr

		inst = curr
	}

	# we have to return the "real" instance of the class
	inst = _Alta_get_real(inst)

	return inst as ptr void
}

export literal function _Alta_suspendable_push_stack(suspendable: ptr native._Alta_basic_suspendable, stackSize: uint64): void {
	let stack = unsafeAllocate(stackSize) as ptr native._Alta_basic_suspendable_stack
	let prev = suspendable.current_stack

	stack.size = stackSize
	stack.next = prev
	stack.prev = nullptr

	if prev {
		prev.prev = stack
	} else {
		# we only update the head pointer when we did not previously have a stack
		# (i.e. when we first create the suspendable context). the first stack
		# is always guaranteed to be the parameter stack.
		#
		# other stacks are guaranteed to be reloaded using _Alta_suspendable_reload_continue
		# immediately after pushing them (with this function), so that function will take care
		# of updating the head pointer
		suspendable.current_stack = stack
	}
}

export literal function _Alta_suspendable_pop_stack(suspendable: ptr native._Alta_basic_suspendable): void {
	let stack = suspendable.current_stack
	let next = stack.next

	if next {
		next.prev = nullptr
	}

	suspendable.current_stack = next

	unsafeFree(stack as ptr void)
}

export literal function _Alta_suspendable_alloca(suspendable: ptr native._Alta_basic_suspendable, offset: uint64): ptr void {
	return ((suspendable.current_stack as ptr byte) + offset) as ptr void
}

export literal function _Alta_suspendable_reload(suspendable: ptr native._Alta_basic_suspendable): void {
	let rootStack = suspendable.current_stack

	while rootStack.next {
		rootStack = rootStack.next
	}

	suspendable.current_stack = rootStack
}

export literal function _Alta_suspendable_reload_continue(suspendable: ptr native._Alta_basic_suspendable): void {
	suspendable.current_stack = suspendable.current_stack.prev
}
