import rawconststring, Size from "types"
import power from "math"
import rawstringLength, String from "string"
import fmod, modf from "libc/lib/math"

export enum Error: int {
  None = 0,
  Unknown = 1,
  InvalidDigit,
  InvalidRadix,
  IntegerOverflow,
}

export function parseNumber<T>(string: String, radix: Size = 10): Result<T, Error> {
  if radix > 36
    return new Result<T, Error>(error: Error.InvalidRadix)

  let result: T = 0
  let negate = false

  for i: Size in string.length::0 {
    let idx = i - 1
    let digit = 0

    if idx == 0 && string[idx] == '-' {
      negate = true
    } else if string[idx] >= '0' && string[idx] <= '9' {
      digit = string[idx] - '0'
    } else if string[idx] >= 'a' && string[idx] <= 'z' {
      digit = string[idx] - 'a' + 10
    } else if string[idx] >= 'A' && string[idx] <= 'Z' {
      digit = string[idx] - 'A' + 10
    } else {
      return new Result<T, Error>(error: Error.InvalidDigit)
    }

    if digit >= radix
      return new Result<T, Error>(error: Error.InvalidDigit)

    let additional = digit * power<T>(radix, string.length - i)
    let newVal = result + additional

    if newVal < result
      return new Result<T, Error>(error: Error.IntegerOverflow)

    result += additional
  }

  return new Result<T, Error>(ok: negate ? -result : result)
}

export function parseFloatingPoint<T>(string: String, radix: Size = 10): Result<T, Error> {
  if radix > 36
    return new Result<T, Error>(error: Error.InvalidRadix)
  if string.length < 1
    return new Result<T, Error>(error: 0)
  let first: Size = 0
  for i: Size in 0...string.length {
    if i == string.length {
      first = string.length
      break
    }
    let char = string[i]
    if !(
      (char >= '0' && char <= '9') ||
      (char >= 'a' && char <= 'z') ||
      (char >= 'A' && char <= 'Z')
    ) {
      first = i
      break
    }
  }
  if first == 0 && string[0] != '.'
    return new Result<T, Error>(ok: 0)
  let maybeWhole = parseNumber<T>(string.substring(0, to: first), radix)
  if maybeWhole.isError {
    return maybeWhole
  }
  let whole = maybeWhole.value
  if first == string.length
    return new Result<T, Error>(ok: whole)

  let isExponent = false
  let charThere = string[first]
  if charThere == '.' {
    isExponent = false
  } else if charThere == 'e' || charThere == 'E' || charThere == 'p' || charThere == 'P' {
    isExponent = true
  } else {
    return new Result<T, Error>(ok: whole)
  }

  let second: Size = 0
  ;++first
  for i: Size in first...string.length {
    if i == string.length {
      second = string.length
      break
    }
    let char = string[i]
    if !(
      (char >= '0' && char <= '9') ||
      (char >= 'a' && char <= 'z') ||
      (char >= 'A' && char <= 'Z')
    ) {
      second = i
      break
    }
  }
  if second == first
    return new Result<T, Error>(ok: whole)

  let maybeSecondPart = parseNumber<T>(string.substring(first, to: second), radix)
  if maybeSecondPart.isError {
    return maybeSecondPart
  }
  let secondPart = maybeSecondPart.value

  if isExponent {
    return new Result<T, Error>(ok: whole * power<T>(10, secondPart))
  } else {
    let decimal = whole + (secondPart / power<T>(radix, second - first))
    if second == string.length
      return new Result<T, Error>(ok: decimal)
    if string[second] != 'e' && string[second] != 'E'
      return new Result<T, Error>(ok: decimal)

    let third: Size = 0
    ;++second
    for i: Size in second...string.length {
      if i == string.length {
        third = string.length
        break
      }
      let char = string[i]
      if !(
        (char >= '0' && char <= '9') ||
        (char >= 'a' && char <= 'z') ||
        (char >= 'A' && char <= 'Z')
      ) {
        third = i
        break
      }
    }
    if third == second
      return new Result<T, Error>(ok: decimal)

    let maybeThirdPart = parseNumber<T>(string.substring(second, to: third), radix)
    if maybeThirdPart.isError {
      return maybeThirdPart
    }
    let thirdPart = maybeThirdPart.value

    return new Result<T, Error>(ok: decimal * power<T>(10, thirdPart))
  }
}

export function numberToString<T>(number: T, radix: Size = 10): String {
  assert radix <= 36
  let negate = false
  if number < 0 {
    negate = true
    number = -number
  }

  let result = new String
  let iteration = 1
  while number >= 1 {
    let mod = power<T>(radix, iteration)
    let num: T
    let digit: byte
    if mod == 0 {
      # we've overflowed the type. assume this is intentional
      # and try to determine the digit by simply dividing by one less
      # than the power of the radix
      num = number
      digit = number / power<T>(radix, iteration - 1)
    } else {
      num = number % mod
      digit = (num * radix / mod) & 0xff
    }

    if digit < 10 {
      result ^= digit + '0'
    } else {
      result ^= digit - 10 + 'a'
    }

    number -= num

    ;++iteration
  }

  if result.length == 0
    result += '0'

  if negate
    result ^= '-'

  return result
}

export function floatingPointToString<T>(number: T, radix: Size = 10): String {
  assert radix <= 36
  let negate = false
  if number < 0 {
    negate = true
    number = -number
  }

  let whole: T = 0
  let frac = modf(number, &whole)

  let result = new String
  let iteration = 1
  while whole >= 1 {
    let mod = power<T>(radix, iteration)
    let num = fmod(whole, mod)
    let digit: byte = num * radix / mod

    if digit < 10 {
      result ^= digit + '0'
    } else {
      result ^= digit - 10 + 'a'
    }

    whole -= num

    ;++iteration
  }

  if result.length == 0
    result += '0'

  result += '.'
  iteration = 1

  while frac > 0 {
    let mod = power<T>(radix, -iteration)
    let num = fmod(frac, mod)
    let digit: byte = (frac - num) / mod

    if digit < 10 {
      result += digit + '0'
    } else {
      result += digit - 10 + 'a'
    }

    frac = num
    ;++iteration

    # maximum significant decimal places of a double = 15
    # long double? not that big of a difference, so just lump it in there, too
    if iteration == 16 {
      break
    }
  }

  if result.length == 0 || result[result.length - 1] == '.'
    result += '0'

  for i: Size in result.length::0 {
    let char = result[i - 1]
    if char != '0' {
      if char == '.' {
        result = result.substring(length: result.length - 1)
      }
      break
    }
    result = result.substring(length: result.length - 1)
  }

  if negate
    result ^= '-'

  return result
}
