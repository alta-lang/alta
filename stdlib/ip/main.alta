import Vector from "vector"
import uint8, uint16, uint32, Size, SizeMaximum, UInt32ToUInt8, UInt16ToUInt8 from "types"
import parseNumber, numberToString from "util"
import String from "string"

export class Address {
  private var _isV6 = false
  private var _components = new Vector<uint16>(6)

  # @brief Constructs an IPv4 `Address` with all components initialized to 0
  public constructor() {
    for i: uint8 in 0..4 {
      this._components.push(0)
    }
  }

  # @brief Constructs an `Address` with all components intialized to 0
  #
  # @param isIPv6 If `true`, the new address will be IPv6. Otherwise, it will be IPv4
  public constructor(isIPv6: bool) {
    for i: uint8 in 0..(isIPv6 ? 8 : 4) {
      this._components.push(0)
    }
  }

  # @brief Constructs an `Address` by parsing the given string as an IPv4 or IPv6 address
  #
  # @param address The string to parse as an address
  #
  # @note This constructor asserts if the parsing fails.
  public @from constructor(address: String) {
    let parsed = this.tryFrom(address)
    assert parsed
    this = *parsed
  }

  # @brief Tries to constructs an `Address` by parsing the given string as an IPv4 or IPv6 address
  #
  # @param address The string to parse as an address
  public static function tryFrom(address: String): Address? {
    let addr = new Address

    let found = false
    for i: Size in 0..address.length {
      if address[i] == ':' {
        addr._isV6 = true
        break
      }
    }
    for i: uint8 in 0..(addr._isV6 ? 8 : 4) {
      addr._components.push(0)
    }

    if address.length == 2 && address[0] == ':' && address[1] == ':' {
      # do nothing
    } else if addr._isV6 {
      let lastIdx: Size? = SizeMaximum # start with SizeMaximum so it'll wrap around to 0 when we do `from: *lastIdx + 1`
      let doubleIndex: uint8? = null
      let componentIdx: uint8 = 0
      while lastIdx {
        if componentIdx > 7
          return null

        let nextIdx = address.indexOf(':', after: *lastIdx)

        let substr = address.substring(from: *lastIdx + 1, to: nextIdx == SizeMaximum ? address.length : nextIdx)

        if substr.length == 0 {
          if doubleIndex
            return null
          doubleIndex = componentIdx
          if *lastIdx == SizeMaximum {
            nextIdx = address.indexOf(':', after: nextIdx)
          }
        } else {
          let maybe = parseNumber<uint16>(substr, 16)
          if maybe.isError {
            return null
          }
          addr._components[componentIdx++] = maybe.value
        }

        if nextIdx == SizeMaximum {
          lastIdx = null
        } else {
          lastIdx = nextIdx
        }

        if lastIdx && *lastIdx + 1 >= address.length {
          return null
        }
      }
      if !doubleIndex && componentIdx < 8
        return null
      if doubleIndex {
        let diff = addr._components.length - componentIdx
        for i: uint8 in *doubleIndex..componentIdx {
          addr._components[i + diff] = addr._components[i]
        }
        for i: uint8 in *doubleIndex..*doubleIndex + diff {
          addr._components[i] = 0
        }
      }
    } else {
      let first = address.indexOf('.')
      let second = address.indexOf('.', after: first)
      let third = address.indexOf('.', after: second)

      if first != SizeMaximum && second != SizeMaximum && third != SizeMaximum && address.indexOf('.', after: third) != SizeMaximum {
        return null
      }

      if first == SizeMaximum {
        # a (uint32)
        let maybe = parseNumber<uint32>(address)
        if maybe.isError {
          return null
        }
        let num: UInt32ToUInt8 = maybe.value
        addr._components[0] = num.part4
        addr._components[1] = num.part3
        addr._components[2] = num.part2
        addr._components[3] = num.part1
      } else if second == SizeMaximum {
        # a.b (uint8.uint24)
        # no 24-bit integer type so just upgrade it to uint32
        let maybe = parseNumber<uint32>(address.substring(from: first + 1, to: address.length))
        if maybe.isError {
          return null
        }
        let num: UInt32ToUInt8 = maybe.value
        let maybe2 = parseNumber<uint8>(address.substring(from: 0, to: first))
        if maybe2.isError {
          return null
        }
        addr._components[0] = maybe2.value
        addr._components[1] = num.part3
        addr._components[2] = num.part2
        addr._components[3] = num.part1
      } else if third == SizeMaximum {
        # a.b.c (uint8.uint8.uint16)
        let maybe = parseNumber<uint16>(address.substring(from: second + 1, to: address.length))
        if maybe.isError {
          return null
        }
        let num: UInt16ToUInt8 = maybe.value
        let maybe2 = parseNumber<uint8>(address.substring(from: 0, to: first))
        if maybe2.isError {
          return null
        }
        addr._components[0] = maybe2.value
        maybe2 = parseNumber<uint8>(address.substring(from: first + 1, to: second))
        if maybe2.isError {
          return null
        }
        addr._components[1] = maybe2.value
        addr._components[2] = num.part2
        addr._components[3] = num.part1
      } else {
        # a.b.c.d (uint8.uint8.uint.uint8)
        # this is the standard notation for IPv4 addresses
        # the others have just been added for compatibility with conventions
        # established by IP parsing functions in other languages (such as `inet_aton`)
        let maybe = parseNumber<uint16>(address.substring(from: 0, to: first))
        if maybe.isError {
          return null
        }
        addr._components[0] = maybe.value
        maybe = parseNumber<uint16>(address.substring(from: first + 1, to: second))
        if maybe.isError {
          return null
        }
        addr._components[1] = maybe.value
        maybe = parseNumber<uint16>(address.substring(from: second + 1, to: third))
        if maybe.isError {
          return null
        }
        addr._components[2] = maybe.value
        maybe = parseNumber<uint16>(address.substring(from: third + 1, to: address.length))
        if maybe.isError {
          return null
        }
        addr._components[3] = maybe.value
      }
    }

    return addr
  }

  public @from constructor(address: uint32) {
    let num: UInt32ToUInt8 = address
    this._components = new Vector<uint16>(items: num.part4, num.part3, num.part2, num.part1)
  }

  # @brief If true, this address is an [IPv4](https://en.wikipedia.org/wiki/IPv4) address.
  public @read function isIPv4(): bool {
    return !this._isV6
  }

  # @brief If true, this address is an [IPv6](https://en.wikipedia.org/wiki/IPv6) address.
  public @read function isIPv6(): bool {
    return this._isV6
  }

  # @brief Accesses a component at the specified index
  # @returns A reference to the component at the index
  # @param $ The index of the desired component
  # @note Asserts when trying to access past the:
  #         * 3rd index (base-0) for IPv4
  #         * 7th index (base-0) for IPv6
  public this[uint8]: ref uint16 {
    # limit index to uint8 since we can only have up to 8 components
    # limit return value to uint16 since we components can have a maximum of 16 bits

    if this._isV6 {
      assert $ < 8
    } else if !this._isV6 {
      assert $ < 4
    }
    return this._components[$]
  }

  # @returns A string representation of this Address
  # @note IPv6 addresses will be represented with full shorthand (i.e. leading zeros and
  #       consecutive zero components omitted) and components will be in hexadecimal format
  # @note IPv4 addresses will be represented normally&mdash;i.e. decimal formatted
  #       components joined with dots (`.`)
  public to String {
    if this._isV6 {
      let longestIdx: uint8 = 0
      let longestCount: uint8 = 0
      let currentCount: uint8 = 0
      let lastIdx: uint8 = 0

      for i: uint8 in 0..this._components.length {
        if this._components[i] == 0 {
          if longestCount == 0 || lastIdx + 1 != i {
            currentCount = 0
          }
          lastIdx = i
          ;++currentCount
          if currentCount > longestCount {
            longestCount = currentCount
            longestIdx = i + 1 - currentCount
          }
        }
      }

      if longestCount == this._components.length {
        return "::"
      }

      let result: String
      let isFirst = true

      if longestCount > 1 {
        for i: uint8 in 0..longestIdx {
          if isFirst {
            isFirst = false
          } else {
            result += ':'
          }
          result += numberToString<uint16>(this._components[i], 16)
        }

        result += ':'
        isFirst = false
      }

      for i: uint8 in (longestCount > 1 ? longestIdx + longestCount : 0)..this._components.length {
        if isFirst {
          isFirst = false
        } else {
          result += ':'
        }
        result += numberToString<uint16>(this._components[i], 16)
      }

      if longestIdx + longestCount == this._components.length {
        result += ':'
      }

      return result
    } else {
      return
        numberToString<uint16>(this._components[0], 10) + '.' +
        numberToString<uint16>(this._components[1], 10) + '.' +
        numberToString<uint16>(this._components[2], 10) + '.' +
        numberToString<uint16>(this._components[3], 10)
    }
  }

  public to uint32 {
    assert !this._isV6

    let num: UInt32ToUInt8 = 0
    num.part1 = this._components[3]
    num.part2 = this._components[2]
    num.part3 = this._components[1]
    num.part4 = this._components[0]

    return num
  }
}
