import Size, uint64, int64 from "types"
import Exception from "exceptions"
import Vector from "vector"
import maximum from "./misc.alta"

type IntegerUnit = unsigned int
let IntegerUnitMaximum: const IntegerUnit = -1 as IntegerUnit
let IntegerUnitBits: const Size = sizeof IntegerUnit * 8

generic function bitLengthOf<T>(integer: T): Size {
  let length = sizeof T * 8
  while length > 0 && ((integer >> (length - 1)) & 1) == 0
    --length
  return length
}

export class HeapIntegerTooBig extends Exception {}

# @summary Unlimited integer class
# @description
#   `Integer` is a class that can represent any integer, with no
#   restrictions on bit width. It supports casting to and from fixed
#   width integer types, but internally, it will use the most efficient
#   storage means, whatever that may be (local fixed width type or heap-allocated
#   dynamically sized buffer).
#
#   It defines all the common operators, including bitwise operators, making operations
#   with it much more natural.
export class Integer {
  private var _local: IntegerUnit? = null
  # the heap is a vector of integer units in little endian order
  # (i.e. [0] is the least significant, [length - 1] is the most significant)
  private var _heap: Vector<IntegerUnit>? = null
  private var _negative: bool = false

  private generic function assignAuto<T>(newValue: T): void {
    this._negative = newValue < 0
    if this._negative
      newValue *= -1
    if bitLengthOf<T>(newValue) > IntegerUnitBits {
      this._local = null
      this._heap = new Vector<IntegerUnit>
      let heap: ref Vector<IntegerUnit> = *this._heap
      let copy: T = newValue
      while copy > 0 {
        heap.push(copy & IntegerUnitMaximum)
        copy = (copy as uint64) >> IntegerUnitBits
      }
    } else {
      this._heap = null
      this._local = newValue
    }
  }

  private function replaceWith(newValue: ref const Integer): void {
    this._negative = newValue._negative
    this._heap = newValue._heap
    this._local = newValue._local
  }

  private @read function currentBitLength(): Size {
    if this._heap {
      let heap: ref Vector<IntegerUnit> = *this._heap
      if heap.length == 0
        return 0
      return ((heap.length - 1) * 8) + bitLengthOf<IntegerUnit>(heap.last)
    } else {
      return bitLengthOf<IntegerUnit>(*this._local)
    }
  }

  public constructor() {
    this._local = 0
  }
  private constructor(vector: Vector<IntegerUnit>) {
    if vector.length == 0 {
      this._local = 0
    } else if vector.length == 1 {
      this._local = vector[0]
    } else {
      let length = vector.length
      while vector[length - 1] == 0
        --length
      this._heap = vector.to(length - 1)
    }
  }
  private constructor(value: IntegerUnit) {
    this._local = value
  }
  public @from constructor(integer: int) {
    this.assignAuto<int>(integer)
  }
  public @from constructor(integer: unsigned int) {
    this.assignAuto<unsigned int>(integer)
  }
  public @from constructor(integer: int64) {
    this.assignAuto<int64>(integer)
  }
  public @from constructor(integer: uint64) {
    this.assignAuto<uint64>(integer)
  }
  public @copy constructor(integer: ref const Integer) {
    this.replaceWith(integer)
  }

  private function negate(): ref Integer {
    this._negative = !this._negative
    return this
  }

  private function add(other: ref const Integer): ref Integer {
    if this.currentBitLength == 0 {
      this.replaceWith(other)
      return this
    } else if other.currentBitLength == 0 {
      return this
    }
    if this._negative && !other._negative {
      return this.negate().subtract(other).negate()
    } else if !this._negative && other._negative {
      return this.subtract((new Integer(other)).negate())
    }
    let maxBits = maximum<Size>(this.currentBitLength, other.currentBitLength)
    if maxBits > IntegerUnitBits {
      let vec = new Vector<IntegerUnit>(length: (maxBits + 1 + (IntegerUnitBits - 1)) / IntegerUnitBits, initializer: 0)
      if this.currentBitLength <= IntegerUnitBits
        vec[0] = *this._local
      else
        vec.replace(0, *this._heap)
      if other.currentBitLength <= IntegerUnitBits {
        let sum = vec[0] + *other._local
        let carry: IntegerUnit = (sum < vec[0] || sum < *other._local) ? 1 : 0
        vec[0] = sum
        for item: ref IntegerUnit in vec.items {
          let nextCarry = item == IntegerUnitMaximum ? 1 : 0
          item += carry
          carry = nextCarry
          if carry == 0
            break
        }
        assert carry == 0
      } else {
        let otherHeap: ref Vector<IntegerUnit> = *other._heap
        let carry: IntegerUnit = 0
        for i: Size in 0..otherHeap.length {
          let sum = vec[i] + otherHeap[i] + carry
          carry = (sum < vec[i] || sum < otherHeap[i]) ? 1 : 0
          vec[i] = sum
        }
        if carry > 0 {
          for i: Size in otherHeap.length..vec.length {
            let nextCarry = vec[i] == IntegerUnitMaximum ? 1 : 0
            vec[i] += carry
            carry = nextCarry
            if carry == 0
              break
          }
          assert carry == 0
        }
      }
      this._heap = vec
      this._local = null
    } else if maxBits == IntegerUnitBits {
      # since `currentBitLength` measure the numbers of *actual* bits, not the space allocated,
      # we *know* that this operation will overflow
      this._heap = new Vector<IntegerUnit>(items: *this._local + *other._local, 0)
      this._local = null
    } else {
      this._local = *this._local + *other._local
      this._heap = null
    }
    return this
  }

  private function subtract(other: ref const Integer): ref Integer {
    if this.currentBitLength == 0 {
      this.replaceWith(other)
      return this
    } else if other.currentBitLength == 0 {
      return this
    }
    if this._negative && !other._negative {
      return this.add((new Integer(other)).negate())
    } else if !this._negative && other._negative {
      return this.negate().add(other).negate()
    }
    let maxBits = maximum<Size>(this.currentBitLength, other.currentBitLength)
    if maxBits > IntegerUnitBits {
      let vec = new Vector<IntegerUnit>(length: (maxBits + (IntegerUnitBits - 1)) / IntegerUnitBits, initializer: 0)
      if this.currentBitLength <= IntegerUnitBits
        vec[0] = *this._local
      else
        vec.replace(0, *this._heap)
      if other.currentBitLength <= IntegerUnitBits {
        let sum = vec[0] - *other._local
        let carry: IntegerUnit = (sum > vec[0] || sum > *other._local) ? 1 : 0
        vec[0] = sum
        for item: ref IntegerUnit in vec.items {
          let nextCarry = item == 0 ? 1 : 0
          item -= carry
          carry = nextCarry
          if carry == 0
            break
        }
        assert carry == 0
      } else {

      }
    } else {
      if *other._local > *this._local {
        this._local = *other._local - *this._local
        this.negate()
      } else {
        this._local = *this._local - *other._local
      }
    }
    return this
  }

  private function equals(other: ref const Integer): bool {
    if this._negative != other._negative
      return false
    if this._local && other._local {
      return *this._local == *other._local
    } else if this._heap && other._heap {
      if (*this._heap).length != (*other._heap).length
        return false
      for i: Size in 0..(*this._heap).length {
        if (*this._heap)[i] != (*other._heap)[i]
          return false
      }
      return true
    } else {
      return false
    }
  }

  private function isLessThan(other: ref const Integer): bool {
    if this._negative {
      if !other._negative
        return true
      if this.currentBitLength < other.currentBitLength
        return false
      else if this.currentBitLength > other.currentBitLength
        return true
      if this._local
        return *this._local > *other._local
      let thisHeap: ref Vector<IntegerUnit> = *this._heap
      let thatHeap: ref Vector<IntegerUnit> = *other._heap
      for i: Size in thisHeap.length::0 {
        if thisHeap[i - 1] > thatHeap[i - 1]
          return true
      }
      return false
    } else {
      if other._negative
        return false
      if this.currentBitLength > other.currentBitLength
        return false
      else if this.currentBitLength < other.currentBitLength
        return true
      if this._local
        return *this._local < *other._local
      let thisHeap: ref Vector<IntegerUnit> = *this._heap
      let thatHeap: ref Vector<IntegerUnit> = *other._heap
      for i: Size in thisHeap.length::0 {
        if thisHeap[i - 1] < thatHeap[i - 1]
          return true
      }
      return false
    }
  }

  private function isGreaterThan(other: ref const Integer): bool {
    if this._negative {
      if !other._negative
        return true
      if this.currentBitLength > other.currentBitLength
        return false
      else if this.currentBitLength < other.currentBitLength
        return true
      if this._local
        return *this._local < *other._local
      let thisHeap: ref Vector<IntegerUnit> = *this._heap
      let thatHeap: ref Vector<IntegerUnit> = *other._heap
      for i: Size in thisHeap.length::0 {
        if thisHeap[i - 1] < thatHeap[i - 1]
          return true
      }
      return false
    } else {
      if other._negative
        return false
      if this.currentBitLength < other.currentBitLength
        return false
      else if this.currentBitLength > other.currentBitLength
        return true
      if this._local
        return *this._local > *other._local
      let thisHeap: ref Vector<IntegerUnit> = *this._heap
      let thatHeap: ref Vector<IntegerUnit> = *other._heap
      for i: Size in thisHeap.length::0 {
        if thisHeap[i - 1] > thatHeap[i - 1]
          return true
      }
      return false
    }
  }

  public this + Integer: Integer {
    return (new Integer(this)).add($)
  }
  public Integer + this: Integer {
    return (new Integer($)).add(this)
  }

  public this += Integer: ref Integer {
    return this.add($)
  }

  public this == Integer: bool {
    return this.equals($)
  }
  public Integer == this: bool {
    return $.equals(this)
  }

  public this != Integer: bool {
    return !this.equals($)
  }
  public Integer != this: bool {
    return !$.equals(this)
  }

  public this < Integer: bool {
    return this.isLessThan($)
  }
  public Integer < this: bool {
    return $.isLessThan(this)
  }

  public this > Integer: bool {
    return this.isGreaterThan($)
  }
  public Integer > this: bool {
    return $.isGreaterThan(this)
  }

  public this <= Integer: bool {
    return this.equals($) || this.isLessThan($)
  }
  public Integer <= this: bool {
    return $.equals(this) || $.isLessThan(this)
  }

  public this >= Integer: bool {
    return this.equals($) || this.isGreaterThan($)
  }
  public Integer >= this: bool {
    return $.equals(this) || $.isGreaterThan(this)
  }
}
