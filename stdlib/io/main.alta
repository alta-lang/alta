import "libc/lib/stdio" as stdio
import String, rawstringLength from "string"
import rawstring, rawconststring, Size from "types"
import Exception, InvalidArgument from "exceptions"
import numberToString, floatingPointToString from "util"
import INT_MAX from "libc/lib/limits"

export stdio.printf as printf

##if platform == "windows"
@@CTranspiler.include("Windows.h");

declare literal function SetConsoleCP(cp: unsigned int): int
declare literal function SetConsoleOutputCP(cp: unsigned int): int

declare literal var CP_UTF8: const unsigned int

let utf8Set = false
##end if

function ensureUTF8Output(): void {
##if platform == "windows"
  if !utf8Set {
    utf8Set = true
    SetConsoleCP(CP_UTF8)
    SetConsoleOutputCP(CP_UTF8)
  }
##end if
}

export class OpenFailure extends Exception {}
export class CloseFailure extends Exception {}
export class ReadFailure extends Exception {}
export class EndOfFile extends Exception {}

export class File {
  private var handle: ptr stdio.FILE = nullptr
  private var path = new String
  private var mode = new String

  public constructor() {}
  public constructor(path: rawconststring) {
    this.open(path, "r")
  }
  public constructor(path: rawconststring, mode: rawconststring) {
    this.open(path, mode)
  }

  public @copy constructor(other: ref File) {
    this.open(other.path, other.mode)
  }

  public destructor() {
    this.close()
  }

  public function open(path: rawconststring, mode: rawconststring): void {
    this.handle = stdio.fopen(path, mode)
    if !this.handle {
      this.handle = nullptr
      throw new OpenFailure
    }
    this.path = path
    this.mode = mode
  }

  public function close(): void {
    if this.handle {
      if stdio.fclose(this.handle) {
        throw new CloseFailure
      }
      this.handle = nullptr
    }
  }

  public function read(): byte {
    let char = stdio.fgetc(this.handle)
    if char == stdio.EOF
      throw new EndOfFile
    return char as byte
  }

  public function read(count: Size): String {
    let str = new String(count)
    while count > INT_MAX {
      if !stdio.fgets(str, INT_MAX, this.handle) {
        throw new ReadFailure
      }
      count -= INT_MAX
    }
    # `as int` isn't necessary, but it's used to silence a compiler warning
    if !stdio.fgets(str, count as int, this.handle) {
      throw new ReadFailure
    }
    return str.substring(0, length: str.length)
  }

  public @read function valid(): bool {
    return this.handle != nullptr
  }

  public @read function file(): ptr stdio.FILE {
    return this.handle
  }

  public @read function ended(): bool {
    return !!stdio.feof(this.handle)
  }

  public to ptr stdio.FILE {
    return this.handle
  }

  public to bool {
    return this.valid
  }
}

export type ConsoleData = String | double | int | char | bool

function toString(data: ConsoleData): String {
  if data instanceof String {
    return data as String
  } else if data instanceof double {
    return floatingPointToString<double>(data as double)
  } else if data instanceof char {
    let char = data as char
    return new String(&char, 1)
  } else if data instanceof int {
    return numberToString<int>(data as int)
  } else if data instanceof bool {
    return (data as bool) ? "true" : "false"
  }
  # this is literally impossible, but just in case...
  throw new InvalidArgument
}

export function print(data: ConsoleData...): void {
  ensureUTF8Output()
  for i: Size in 0..data.length {
    stdio.printf("%s", toString(data[i]).data)
  }
}

export function printLine(data: ConsoleData...): void {
  for i: Size in 0..data.length {
    print(data[i])
  }
  stdio.printf("\n")
}

export function printLine(message: rawconststring): void {
  ensureUTF8Output()
  stdio.printf("%s\n", message)
}

export function printError(data: ConsoleData...): void {
  ensureUTF8Output()
  for i: Size in 0..data.length {
    stdio.fprintf(stdio.stderr, "%s", toString(data[i]).data)
  }
  stdio.fprintf(stdio.stderr, "\n")
}

export function printError(message: rawconststring): void {
  ensureUTF8Output()
  stdio.fprintf(stdio.stderr, "%s\n", message)
}

export function format(data: ConsoleData...): String {
  let result = new String
  for i: Size in 0..data.length {
    result += toString(data[i])
  }
  return result
}
