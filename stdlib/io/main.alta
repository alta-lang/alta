import "libc/lib/stdio" as stdio
import String, rawstringLength from "string"
import rawstring, Size from "types"
import Exception, InvalidArgument from "exceptions"
import numberToString, floatingPointToString from "util"

export stdio.printf as printf

export class OpenFailure extends Exception {}
export class CloseFailure extends Exception {}
export class ReadFailure extends Exception {}

export class File {
  private var handle: ptr stdio.FILE = nullptr
  private var path = new String
  private var mode = new String

  public constructor() {}
  public constructor(path: rawstring) {
    this.open(path, "r")
  }
  public constructor(path: String) {
    this.open(path.data, "r")
  }
  public constructor(path: rawstring, mode: rawstring) {
    this.open(path, mode)
  }
  public constructor(path: String, mode: rawstring) {
    this.open(path.data, mode)
  }

  public @copy constructor(other: ref File) {
    this.open(other.path.data, other.mode.data)
  }

  public function open(path: rawstring, mode: rawstring): void {
    this.handle = stdio.fopen(path, mode)
    if !this.handle {
      this.handle = nullptr
      throw new OpenFailure
    }
    this.path = new String(path)
    this.mode = new String(mode)
  }

  public function close(): void {
    if this.handle {
      if stdio.fclose(this.handle) {
        throw new CloseFailure
      }
      this.handle = nullptr
    }
  }

  public function read(): byte {
    let char = stdio.fgetc(this.handle)
    if char == stdio.EOF return '\0'
    return char as byte
  }

  public function read(count: Size): String {
    let str = new String(count)
    if !stdio.fgets(str.data, count, this.handle) {
      throw new ReadFailure
    }
    return str.substring(0, length: rawstringLength(str.data))
  }

  public @read function valid(): bool {
    return this.handle != nullptr
  }

  public @read function file(): ptr stdio.FILE {
    return this.handle
  }
}

export function print(data: (String | rawstring | double | int | char)...): void {
  let result: String
  for i: Size in 0..data.length {
    let item = data[i]
    if item instanceof String {
      result.append(item as String)
    } else if item instanceof rawstring {
      result.append(item as rawstring)
    } else if item instanceof double {
      result.append(floatingPointToString<double>(item as double))
    } else if item instanceof char {
      result.append(item as char)
    } else if item instanceof int {
      result.append(numberToString<int>(item as int))
    } else {
      # this is literally impossible, but just in case...
      throw new InvalidArgument
    }
  }
  stdio.printf("%s", result.data)
}

export function printLine(message: rawstring): void {
  stdio.printf("%s\n", message)
}
export function printLine(message: String): void {
  printLine(message.data)
}

export function printError(message: rawstring): void {
  stdio.fprintf(stdio.stderr, "%s\n", message)
}
export function printError(message: String): void {
  printError(message.data)
}
