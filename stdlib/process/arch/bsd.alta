import rawstring, Size from "types"
import allocate, free from "memory"
import memcpy from "libc/lib/string"
import String from "string"
import Vector from "Vector"
import Error from "./posix.alta"

##if platform == "darwin"
  var CTL_KERN: const int = 1
  var KERN_ARGMAX: const int = 8
##end if

declare literal function sysctl(name: ptr int, nameLength: unsigned int, oldBuffer: ptr void, oldLength: ptr Size, newBuffer: ptr void, newLength: ptr Size): int
declare literal function getpid(): int

export function rawArgs(): Result<Vector<String>, Error> {
  # mib = Management Information Base
  let mib = *allocate<int>(3)

  mib[0] = CTL_KERN
  mib[1] = KERN_ARGMAX

  let maxArgSize: int = 0
  let inputSize: Size = sizeof int

  if sysctl(mib, 2, &maxArgSize as ptr void, &inputSize, nullptr, 0) == -1
    return new Result<Vector<String>, Error>(error: Error.Unknown)

  mib[0] = CTL_KERN
  mib[1] = KERN_PROCARGS2
  mib[2] = getpid()

  let processArguments = *allocate<byte>(maxArgSize)
  inputSize = maxArgSize

  if sysctl(mib, 3, &processArguments as ptr void, &inputSize, nullptr, 0) == -1
    return new Result<Vector<String>, Error>(error: Error.Unknown)

  memcpy(&argc as ptr void, processArguments as ptr void, sizeof int)
  let argPtr: ptr byte = processArguments + sizeof int

  let exe = new String(argPtr)
  argPtr += exe.length

  if argPtr == &processArguments[inputSize]
    return new Result<Vector<String>, Error>(error: Error.Unknown)

  # skip null terminators
  while argPtr < &processArguments[inputSize] {
    if *argPtr != '\0'
      break
    ;++argPtr
  }

  let argv = new Vector<String>
  for i: Size in 0..argc {
    let str = new String(argPtr)
    argv.push(str)
    argPtr += str.size
  }

  free<byte>(processArguments)
  free<int>(mib)

  return new Result<Vector<String>, Error>(ok: argv)
}

export * from "./posix.alta"
