import allocate, reallocate, free from "memory"
import Size, rawstring, rawconststring from "types"
import printf from "libc/lib/stdio"
import strlen from "libc/lib/string"
import Exception, IndexOutOfBoundsException from "exceptions"

##define STRING_DEBUG false

##if STRING_DEBUG
let stringUUID: Size = 0
##end if

export class ResizeFailure extends Exception {}

# Determines the length of a null-terminated rawstring
#
# @param str The string whose length will be calculated
# @returns The length of the rawstring, excluding the null-terminator
export function rawstringLength(str: rawconststring): Size {
  let i: Size = 0
  while str[i] != '\0' {
    ++i
  }
  return i
}

# A basic, ASCII string container
export class String {
  private var _data: rawstring = 0
  private var _length: Size = 0

##if STRING_DEBUG
  private var uuid = stringUUID++
##end if

  # Constructs a new, empty String
  public constructor() {
    this._data = allocate<byte>(1)
    this._data[0] = '\0'

##if STRING_DEBUG
    printf("constructed a new String (%llu)\n", this.uuid)
##end if
  }

  # Constructs a new String given a rawstring (ptr byte)
  #
  # @param data The rawstring to us
  # @note The length will be determined automatically
  #       using `rawstringLength(data)`
  public @from constructor(data: rawconststring) {
    this._length = rawstringLength(data)
    this._data = allocate<byte>(this._length + 1)

    for i: Size in 0..this._length {
      this._data[i] = data[i]
    }

    this._data[this._length] = '\0'

##if STRING_DEBUG
    printf("constructed a new String (%llu)\n", this.uuid)
##end if
  }

  # Constructs a new String given a rawstring (ptr byte) and a length
  #
  # @param data   The rawstring to use
  # @param length The length of the rawstring, *excluding* the null
  #               terminator (i.e. length of "hi" equals 2, not 3)
  public constructor(data: rawconststring, length: Size) {
    this._length = length
    this._data = allocate<byte>(this._length + 1)

    for i: Size in 0..this._length {
      this._data[i] = data[i]
    }

    this._data[this._length] = '\0'

##if STRING_DEBUG
    printf("constructed a new String (%llu)\n", this.uuid)
##end if
  }

  public constructor(length: Size) {
    this._length = length
    this._data = allocate<byte>(this._length + 1)

    for i: Size in 0...this._length {
      this._data[i] = '\0'
    }

##if STRING_DEBUG
    printf("constructed a new String (%llu)\n", this.uuid)
##end if
  }

  # Constructs a new String by copying another String
  #
  # @param other The String to copy
  public @copy constructor(other: ref String) {
    this._length = other._length
    this._data = allocate<byte>(this._length + 1)

    for i: Size in 0..this._length {
      this._data[i] = other._data[i]
    }

    this._data[this._length] = '\0'

##if STRING_DEBUG
    printf("copied a String (%llu -> %llu)\n", other.uuid, this.uuid)
##end if
  }

  public destructor() {
    free<byte>(this._data)

##if STRING_DEBUG
    printf("destroyed a String (%llu)\n", this.uuid)
##end if
  }

  # Retrieves the character at the given index and returns a reference
  # to it, to allow modification
  #
  # If this String is shorter than the length required to have that
  # character, this function will automatically reallocate enough space
  # for it to have a character at the index.
  #
  # @param i The index of the character to retrieve
  # @returns A reference to the character at the given index
  public function charAt(i: Size): ref byte {
    if i >= this._length {
      throw new IndexOutOfBoundsException
    }
    return this._data[i]
  }

  # The pointer to the rawstring (ptr byte) contained
  # by this String
  public @read function data(): rawstring {
    return this._data
  }

  # The length of this String
  #
  # Note that this does *not* include the null terminator
  # i.e. the *length* of "hi" is 2, not 3
  public @read function length(): Size {
    return this._length
  }

  # The size of this String
  #
  # Note that this *does* include the null terminator
  # i.e. the *size* of "hi" is 3, not 2
  public @read function size(): Size {
    return this.length + 1
  }

  public to rawstring {
    return this._data
  }

  private function resize(length: Size): ref String {
    let tmp = reallocate<byte>(this._data, length + 1)

    # TODO: check for null pointer rather than strictly zero.
    #       while extremely unlikely and illogical, a platform
    #       could decide that null pointer is not zero.
    if tmp == nullptr {
      throw new ResizeFailure
    }

    this._data = tmp as rawstring
    this._length = length
    
    return this
  }

  # Appends the given rawstring to this String
  #
  # @param data The string to append
  # @param length The length of the string to append
  # @returns A reference to this String, to allow call chaining
  public function append(data: rawconststring, length: Size): ref String {
    let oldLen = this._length

    this.resize(this._length + length)

    for i: Size in 0..length {
      this._data[oldLen + i] = data[i]
    }

    this._data[this._length] = '\0'

    return this
  }

  # Appends the given rawstring to this String
  #
  # @param data The string to append
  # @returns A reference to this String, to allow call chaining
  # @note The length will be determined automatically
  #       using `rawstringLength(data)`
  public function append(data: rawconststring): ref String {
    return this.append(data, rawstringLength(data))
  }

  # Appends the given String to this String
  #
  # @param data The String to append
  # @returns A reference to this String, to allow call chaining
  public function append(data: String): ref String {
    return this.append(data._data, data._length)
  }

  public function append(data: byte): ref String {
    return this.append(&data, 1)
  }

  public function substring(from: Size, to: Size): String {
    let sub = new String
    for i: Size in from..to {
      if i >= this._length break
      sub.append(this.charAt(i))
    }
    return sub
  }
  # possible because Alta takes parameters names into account when determining overloads
  # and defaults to the first overload found when ambiguities arise
  public function substring(from: Size, length: Size): String {
    return this.substring(from, to: from + length)
  }
  public function substring(from: Size): String {
    return this.substring(from, to: this._length)
  }
  # possible for the same reason as above
  public function substring(to: Size): String {
    return this.substring(0, to: to)
  }
  public function substring(length: Size): String {
    return this.substring(0, length: length)
  }

  public function prepend(data: rawconststring, length: Size): ref String {
    let oldLen = this._length

    this.resize(this._length + length)

    for i: Size in oldLen::0 {
      this._data[i - 1 + length] = this._data[i - 1]
    }

    for i: Size in 0..length {
      this._data[i] = data[i]
    }

    this._data[this._length] = '\0'

    return this
  }

  public function prepend(data: rawconststring): ref String {
    return this.prepend(data, rawstringLength(data))
  }

  public function prepend(data: String): ref String {
    return this.prepend(data._data, data._length)
  }

  public function prepend(data: byte): ref String {
    return this.prepend(&data, 1)
  }

  public function includes(data: byte...): bool {
    for i: Size in 0..this._length {
      for j: Size in 0..data.length {
        if this._data[i] == data[j] {
          return true
        }
      }
    }
    return false
  }

  public this + String: String {
    let other = new String(this)
    other.append($)
    return other
  }

  public this += String: ref String {
    return this.append($)
  }

  public this += byte: ref String {
    return this.append($)
  }

  public this ^= String: ref String {
    return this.prepend($)
  }

  public this ^= byte: ref String {
    return this.prepend($)
  }

  public this[Size]: ref byte {
    return this.charAt($)
  }
}
