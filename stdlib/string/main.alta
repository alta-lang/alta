import allocate, reallocate, free from "memory"
import Size, rawstring, rawconststring, uint32, uint8 from "types"
import printf from "libc/lib/stdio"
import strlen from "libc/lib/string"
import Exception, IndexOutOfBoundsException from "exceptions"
import "unicode" as unicode
import Vector from "vector"

##define STRING_DEBUG false

##if STRING_DEBUG
let stringUUID: Size = 0
##end if

export class ResizeFailure extends Exception {}
export class InvalidCodePoint extends Exception {}

# Determines the length of a null-terminated rawstring
#
# @param str The string whose length will be calculated
# @returns The length of the rawstring, excluding the null-terminator
export function rawstringLength(str: rawconststring): Size {
  let i: Size = 0
  while str[i] != '\0' {
    ++i
  }
  return i
}

export class CodePoint {
  # we have to store references to the String *members* instead of
  # the `String` instance directly because Alta doesn't auto-declare
  # classes yet, so at this point, `String` does not exist
  private var data: ref rawstring
  private var length: ref Size
  private var _index: Size = 0

  public constructor(data: ref rawstring, length: ref Size, index: Size) {
    this.data @strict = data
    this.length @strict = length
    this._index = index
  }

  private function findByteIndex(): Size {
    let i: Size = 0
    for strIdx: Size in 0..this._index {
      let bytes = unicode.detectRequiredUTF8Bytes(this.data[i])
      i += bytes
    }
    return i
  }

  private function resize(idx: Size, needed: Size): void {
    let current = unicode.detectRequiredUTF8Bytes(this.data[idx])

    if needed < current {
      let diff = current - needed
      for i: Size in idx + current..this.length {
        this.data[i - diff] = this.data[i]
      }
      this.length -= diff
      this.data = reallocate<byte>(this.data, this.length)
    } else if needed > current {
      let diff = needed - current
      this.data = reallocate<byte>(this.data, this.length + diff)
      for i: Size in this.length + diff - 1:::idx + current {
        this.data[i] = this.data[i - diff]
      }
      this.length += diff
    }
  }

  public this = uint32: ref CodePoint {
    let idx = this.findByteIndex()

    this.resize(idx, unicode.detectRequiredUTF8BytesForUTF32($))

    let bytes = unicode.utf32ToUTF8($)

    for i: Size in 0..bytes.length {
      this.data[idx + i] = bytes[i]
    }

    return this
  }

  public this = rawconststring: ref CodePoint {
    let strLen = rawstringLength($)
    let idx = this.findByteIndex()

    if strLen == 0
      throw new InvalidCodePoint

    let required = unicode.detectRequiredUTF8Bytes($[0])

    if strLen != required
      throw new InvalidCodePoint

    this.resize(idx, required)

    for i: Size in 0..strLen {
      this.data[idx + i] = $[i]
    }

    return this
  }

  public this = CodePoint: ref CodePoint {
    let idx = this.findByteIndex()
    let otherIdx = $.findByteIndex()
    let required = unicode.detectRequiredUTF8Bytes($.data[otherIdx])

    this.resize(idx, required)

    for i: Size in 0..required {
      this.data[idx + i] = $.data[otherIdx]
    }

    return this
  }

  public to byte {
    let idx = this.findByteIndex()
    let required = unicode.detectRequiredUTF8Bytes(this.data[idx])

    if required > 1
      throw new InvalidCodePoint

    return this.data[idx]
  }

  public to uint32 {
    let idx = this.findByteIndex()
    let required = unicode.detectRequiredUTF8Bytes(this.data[idx])
    let vec = new Vector<uint8>(required)

    for i: Size in 0..required {
      vec.push(this.data[idx + i])
    }

    return unicode.utf8ToUTF32(vec)
  }

  public @read function index(): Size {
    return this._index
  }

  public @read function byteIndex(): Size {
    return this.findByteIndex()
  }

  public @read function byteLength(): Size {
    return unicode.detectRequiredUTF8Bytes(this.data[this.findByteIndex()])
  }

  public @read function bytes(): rawconststring {
    return this.data
  }
}

# A basic, UTF8 string container
export class String {
  private var _data: rawstring = 0
  private var _length: Size = 0

##if STRING_DEBUG
  private var uuid = stringUUID++
##end if

  # Constructs a new, empty String
  public constructor() {
    this._data = allocate<byte>(1)
    this._data[0] = '\0'

##if STRING_DEBUG
    printf("constructed a new String (%llu)\n", this.uuid)
##end if
  }

  # Constructs a new String given a rawstring (ptr byte)
  #
  # @param data The rawstring to us
  # @note The length will be determined automatically
  #       using `rawstringLength(data)`
  public @from constructor(data: rawconststring) {
    this._length = rawstringLength(data)
    this._data = allocate<byte>(this._length + 1)

    for i: Size in 0..this._length {
      this._data[i] = data[i]
    }

    this._data[this._length] = '\0'

##if STRING_DEBUG
    printf("constructed a new String (%llu)\n", this.uuid)
##end if
  }

  # Constructs a new String given a rawstring (ptr byte) and a length
  #
  # @param data   The rawstring to use
  # @param length The length of the rawstring, *excluding* the null
  #               terminator (i.e. length of "hi" equals 2, not 3)
  public constructor(data: rawconststring, length: Size) {
    this._length = length
    this._data = allocate<byte>(this._length + 1)

    for i: Size in 0..this._length {
      this._data[i] = data[i]
    }

    this._data[this._length] = '\0'

##if STRING_DEBUG
    printf("constructed a new String (%llu)\n", this.uuid)
##end if
  }

  public constructor(length: Size) {
    this._length = length
    this._data = allocate<byte>(this._length + 1)

    for i: Size in 0...this._length {
      this._data[i] = '\0'
    }

##if STRING_DEBUG
    printf("constructed a new String (%llu)\n", this.uuid)
##end if
  }

  # Constructs a new String by copying another String
  #
  # @param other The String to copy
  public @copy constructor(other: ref String) {
    this._length = other._length
    this._data = allocate<byte>(this._length + 1)

    for i: Size in 0..this._length {
      this._data[i] = other._data[i]
    }

    this._data[this._length] = '\0'

##if STRING_DEBUG
    printf("copied a String (%llu -> %llu)\n", other.uuid, this.uuid)
##end if
  }

  public destructor() {
    free<byte>(this._data)

##if STRING_DEBUG
    printf("destroyed a String (%llu)\n", this.uuid)
##end if
  }

  # Retrieves the character at the given index and returns a CodePoint
  #
  # @param i The index of the character to retrieve
  # @returns A CodePoint for the code point at the given index
  public function charAt(i: Size): CodePoint {
    if i >= this.length {
      throw new IndexOutOfBoundsException
    }
    return new CodePoint(this._data, this._length, i)
  }

  public function byteAt(i: Size): ref byte {
    if i >= this._length {
      throw new IndexOutOfBoundsException
    }

    return this._data[i]
  }

  # The pointer to the rawstring (ptr byte) contained
  # by this String
  public @read function data(): rawstring {
    return this._data
  }

  # The length of this String
  #
  # Note that this does *not* include the null terminator
  # i.e. the *length* of "hi" is 2, not 3
  public @read function length(): Size {
    let len: Size = this._length
    for i: Size in 0..this._length {
      let bytes = unicode.detectRequiredUTF8Bytes(this.data[i])
      len -= bytes - 1
    }
    return len
  }

  public @read function byteLength(): Size {
    return this._length
  }

  # The size of this String
  #
  # Note that this *does* include the null terminator
  # i.e. the *size* of "hi" is 3, not 2
  public @read function size(): Size {
    return this.length + 1
  }

  public to rawstring {
    return this._data
  }

  private function resize(length: Size): ref String {
    let tmp = reallocate<byte>(this._data, length + 1)

    # TODO: check for null pointer rather than strictly zero.
    #       while extremely unlikely and illogical, a platform
    #       could decide that null pointer is not zero.
    if tmp == nullptr {
      throw new ResizeFailure
    }

    this._data = tmp as rawstring
    this._length = length
    
    return this
  }

  # Appends the given rawstring to this String
  #
  # @param data The string to append
  # @param length The length of the string to append
  # @returns A reference to this String, to allow call chaining
  public function append(data: rawconststring, length: Size): ref String {
    let oldLen = this._length

    this.resize(this._length + length)

    for i: Size in 0..length {
      this._data[oldLen + i] = data[i]
    }

    this._data[this._length] = '\0'

    return this
  }

  # Appends the given rawstring to this String
  #
  # @param data The string to append
  # @returns A reference to this String, to allow call chaining
  # @note The length will be determined automatically
  #       using `rawstringLength(data)`
  public function append(data: rawconststring): ref String {
    return this.append(data, rawstringLength(data))
  }

  # Appends the given String to this String
  #
  # @param data The String to append
  # @returns A reference to this String, to allow call chaining
  public function append(data: String): ref String {
    return this.append(data._data, data._length)
  }

  public function append(data: byte): ref String {
    return this.append(&data, 1)
  }

  public function append(data: CodePoint): ref String {
    return this.append(data.bytes, data.byteLength)
  }

  public function substring(from: Size, to: Size): String {
    let sub = new String
    for i: Size in from..to {
      if i >= this._length break
      sub.append(this.charAt(i))
    }
    return sub
  }
  # possible because Alta takes parameters names into account when determining overloads
  # and defaults to the first overload found when ambiguities arise
  public function substring(from: Size, length: Size): String {
    return this.substring(from, to: from + length)
  }
  public function substring(from: Size): String {
    return this.substring(from, to: this._length)
  }
  # possible for the same reason as above
  public function substring(to: Size): String {
    return this.substring(0, to: to)
  }
  public function substring(length: Size): String {
    return this.substring(0, length: length)
  }

  public function prepend(data: rawconststring, length: Size): ref String {
    let oldLen = this._length

    this.resize(this._length + length)

    for i: Size in oldLen::0 {
      this._data[i - 1 + length] = this._data[i - 1]
    }

    for i: Size in 0..length {
      this._data[i] = data[i]
    }

    this._data[this._length] = '\0'

    return this
  }

  public function prepend(data: rawconststring): ref String {
    return this.prepend(data, rawstringLength(data))
  }

  public function prepend(data: String): ref String {
    return this.prepend(data._data, data._length)
  }

  public function prepend(data: byte): ref String {
    return this.prepend(&data, 1)
  }

  public function prepend(data: CodePoint): ref String {
    return this.prepend(data.bytes, data.byteLength)
  }

  public function includes(data: byte...): bool {
    for i: Size in 0..this._length {
      for j: Size in 0..data.length {
        if this._data[i] == data[j] {
          return true
        }
      }
    }
    return false
  }

  public this + String: String {
    let other = new String(this)
    other.append($)
    return other
  }

  public this + CodePoint: String {
    let other = new String(this)
    other.append($)
    return other
  }

  public this + byte: String {
    let other = new String(this)
    other.append($)
    return other
  }

  public this += String: ref String {
    return this.append($)
  }

  public this += CodePoint: ref String {
    return this.append($)
  }

  public this += byte: ref String {
    return this.append($)
  }

  public this ^= String: ref String {
    return this.prepend($)
  }

  public this ^= CodePoint: ref String {
    return this.prepend($)
  }

  public this ^= byte: ref String {
    return this.prepend($)
  }

  public this[Size]: CodePoint {
    return this.charAt($)
  }
}
